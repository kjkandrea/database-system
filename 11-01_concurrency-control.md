# 동시성 제어

일관성 훼손을 발생시키는 트랜잭션에 대해 동시성 제어를 통해 일관성 유지에 개입하는 것

* 트랜잭션 간 연산의 순서를 제어
* 어떠한 데이터 읽기, 갱신 연산에도 무결성을 유지
* 동시에 실행되는 트랜잭션 수를 증가

## 락 기반 규약

직렬 가능성을 보장하기 위해 락을 사용하여 데이터 항목에 연산 적용 전 트랜잭션이 락을 획득하고 연산 후 반납하도록 하는 규약

* 공유 락(S; shared lock)
  * 데이터 읽기 작업(SELECT)을 안전하게 수행하기 위해 사용
  * 트랜잭션이 공유 락을 획득하면 데이터를 읽을 수 있지만 쓸 수는 없는 락
* 배타 락(X; exclusive lock)
  * 데이터 쓰기 작업(INSERT, UPDATE, DELETE)을 안전하게 수행하기 위해 사용
  * 트랜잭션이 데이터 항목에 배타 락을 획득하면 데이터를 읽고 쓸 수 있는 락
  * 다른 트랜잭션은 해당 데이터 항목에 어떠한 락도 획득 불가

### 락 양립성

트랜잭션은 연산하고자 하는 데이터에 대한 락을 획득해야만 연산 진행 가능

교착 상태(deadlock) : 두 트랜잭션이 교착 상태에 빠진 상태

### 2단계 락킹 규약

트랜잭션이 교착 상태에 빠지지 않기 위한 규약

* 확장 단계 : 락을 얻을 수 있으나 반납할 수 없는 단계
* 축소 단계 : 락을 반납할 수는 있지만 새로운 락을 얻을 수 없는 단계

확장 단계 -> 축소 단계 순으로 진행된다면 직렬성을 보장하나 교착상태 예방 불가

## 타임스탬프 순서 규약

먼저 들어온 트랜잭션이 먼저 실행되게 함으로 직렬성을 확보하려는 전략

* W-TS : Write 를 성공적으로 실행한 트랜잭션 중 가장 최근 타임스탬프
* R-TS: Read 를 성공적으로 실행한 트랜잭션 중 가장 최근 타임스탬프

타임스탬프 할당 방법
* 시스템 클럭 값
* 논리적 계수기

### 토마스 기록 규칙

타임스탬프 순서 규약에서 TS < W-TS 이면 Write 연산을 거부하고 롤백은 하지않음

=> 롤백 연산 수를 줄임

## 교착 상태(deadlock)

특정 트랜잭션 집합 내에 속하는 모든 트랜잭션이 집합 내의 다른 트랜잭션을 기다리고 있는 상태

두 트랜잭션 중 하나를 반드시 롤백시켜야 함

* 교착상태 발생이 비교적 높은 시스템의 경우 => 교착상태 방지 규약
* 교착상태 발생이 비교적 높지 않은 시스템의 경우 => 교착상태 탐지와 회복 기법 사용

### 교착상태 방지 규약

#### 락을 이용한 교착상태 방지

모든 데이터 항목에 대해 락을 설정하는 기법
* 단점 1. 트랜잭션이 시작되기 전에 어떤 데이터에 락을 걸어야 하는지 미리 알기가 어려움
* 단점 2. 락이 걸린 상태에서 많은 데이터들이 오랫동안 사용되지 않아 데이터 항목에 대한 이용률이 매우 낮아짐

#### 타임스탬프를 이용하는 교착상태 방지

Tj가 락을 소유한 데이터 항목을 Ti가 요청하는 상황
* wait-die 기법 (비선점유 기반): TS(Ti) < TS(Tj) 일 때 Ti가 기다리고 그렇지 않으면 Ti를 롤백
* wound-wait 기법(선점유 기반): TS(Ti) < TS(Tj). Tj가 기다리고 그렇지않으면 Ti를 롤백하고 락을 이양

### 교착상태 탐지와 회복

교착상태 발생여부를 판별하기 위한 알고리즘을 주기적으로 수행

#### 탐지 - 대기 그래프(wait-for graph)

* 정점 V는 시스템 내의 트랜잭션으로 구성
* 간선 E는 트랜잭션의 순서쌍 (Ti, Tj)으로 이루어짐

대기 그래프에 사이클이 있다면 교착 상태가 발생했다고 판단

#### 회복 - 희생자 선정 => 희생자 롤백

롤백 비용이 가장 적은 트랜잭션을 선택

* 연산을 수행한 시간과 남은 작업을 마치기 위한 시간
* 사용한 데이터와 트랜잭션 실행에 필요한 추가적인 데이터
* 롤백에 포함되는 트랜잭션의 개수
* 같은 트랜잭션이 항상 희생자로 선정되지 않도록 희생자 선정 시 롤백 횟수를 고려



